Recognizer
    - Reads input, and determines if it belongs to a language

BNF and Context-Free Grammars

    Context-Free
        Developed by Noam Chomsky
        Language generators, meant to describe the syntax of natural language
        Define a class of languages called context-free languages

    Backus-Naur Form
        Invented by John Backus to describe the syntax of Algol 58
        BNF is equivalent to context-free grammars

BNF Fundamentals
    
    In BNF, abstractions are used to represent classes of syntactic structures
        they act like syntactuc variables (called nonterminal symbols, or just nonterminals).

    Terminals are lexemes or tokens.

    A rule has a lhs which must be a single nonterminal 
    and a rhs which is a string of terminals and/or nonterminals

Examples:

    <ident_list> -> IDENTIFIER | IDENTIFIER COMMA <ident_list>
    <if_stmt> -> IF <logic_expr> THEN <stmt>

    Whole Grammar:

        <program>   -> <stmts>
        <stmts>     -> <stmt> | <stmt> ; <stmts>
        <stmt>      -> <var> = <expr>
        <var>       -> a | b | c| d
        <expr>      -> <term> + <term> | <term> - <term>
        <term>      -> <var> | const

Derivations

    Every string of symbols in a derivation is a sentential form, a sentence is a sentential form that has only terminal symbols
    A derivation may be leftmost or rightmost (order in which nonterminals are processed)

Ambiguity in Grammars

    A grammar is ambiguous if and only if a sentential form can generate two valid and distinct parse trees

Avoiding Ambiguity from Operators (Precedence)

    Enforce precedence by making a rule for each level of precedence.
    Each lower level is made up of terms from an upper level
    
    <term> -> <term> * const | <term> / const | const
    <sum>  -> <term> + <sum> | <term> - <sum> | <term>

Avoiding Ambiguity from Operators (Associativity)

    <expr> -> <expr> + <expr> | const (ambiguous)
    <expr> -> <expr> + const  | const (unambiguous)

Extended BNF (EBNF)

    <proc_call> -> ident ([<expr_list>]) //optional in square brackets
    <term> -> <term> (+|-) const
    Repetitions in {}

BNF vs EBNF:
    
    BNF
    <expr> -> <expr> + <term>
            | <expr> - <term>
            | <term>
    <term> -> <term> * <factor>
            | <term> / <factor>
            | <factor>
    
    EBNF
    <expr> -> <term> {(+|-) <term>}
    <term> -> <factor> {(*|/) <factor>}


The Problem of Parsing

    Goals of a Parser
        Either, find all syntax errors and generate diagnostic info
        Or, produce the parse tree / trace of the parse tree

    Two categories
        Top Down (begins at root)
        Bottom Up (begins at leaves)

    Useful Parses only look ONE token ahead in the input

    Top-Down Parser:
        Given sentential form, xA(alpha), 
        the parser must chose the correct A-rule (A is nonterminal) to get to the next sentential form
        in the leftmost derivation, using only the first token produced by A

    Most Common Top-Down Parse Algorithms
        Recursive Descent - a coded implementation
        LL Parsers - table driven implementation

    Bottom-Up Parser:
        Given a right sentential form, (alpha), determine what substring of (alpha) is the rhs
        of the rule in the grammar that must be reduced to produce the previous sentential form in the right sentential

    The Most Common algorithms are in the LR family

    Complexity of Parsing
        Parsers that work for any unambiguous grammar are complex and inefficient, O(n^3), where n is the length
        Compilers use parsers that only work for a subset of all unambiguous grammars, but do it in linear time

Recursive-Descent Parsing

    There is a subprogram for each nonterminal in the grammar, which can parse sentences that can be generated by that nonterminal
    EBNF is ideally suited for being the basis for a recursive-descent parser, because EBNF minimizes the number of nonterminals
    (What Kapleau showed us)


